# qiwi test task
Задача
Отрисовать форму, поведение и вид которой определяется файлом в формате json (содержание файла находится в конце описания
задания и по урлу https://w.qiwi.com/mobile/form/form.json).
Форма должна реагировать на пользовательский ввод описанным в файле поведением.
Валидацию текстовых полей ввода можно проводить по кнопке "валидировать", но в идеале, использовать RxJava throttle метод, то есть
пользователь вводит, что хочет, и если ввода нет определенное количество времени – валидировать содержимое поля.
Можно использовать любой архитектурный паттерн, но для этой задачи неплохо подходит MVVM. Очень желательно разделять логику
построения дерева и рендеринг формы.

Вот что я думаю про все это...
----------

Некоторое время я думал- как это сделать лучше, искал как вообще такое делают люди, искал про MVVM и в итоге вижу два пути:
-	Если бы знать количество и тип полей заранее, т.е если бы мы знали, что на форме всегда есть поле имя, поле фамилия, спиннер c выбором типа идентификатора и т.д

Если бы была теоретическая возможность сделать разметку xml этой формы валидации заранее, можно было бы вообще красиво сделать с data binding.  А из json вытаскивать regex для валидации и прочие настройки полей, вроде того, что клавиатура должна быть цифровая на вводе БИК,  текст при некорректном вводе и т.д и хранить это в ViewModel для конкретного View. В идеале на каждое View должно быть по объекту ViewModel с полями, которые мы и должны связать c настройками View в xml.

Хорошо читается, компактно и легко, вот в таком стиле:

	<variable
            name="element"
            type="com.example.konstantin.qiwi.NameViewModel" />

	<EditText
            ...
	android:hint=="@{element.getView().getPrompt()}"
	android:inputType="@{element.getView().getWidget().getKeyBord()}"
	android:enabled="@{element.getVisibility()}"
            .../>

-	Второй вариант – рассматривать каждый json как описание одного или нескольких деревьев, каждый узел которых является блоком параметров для передачи в конструктор ViewModel. Т.е на основе всех данных можно сконструировать дерево из ViewModel, потом каждый раз при изменении чего-либо обходить потомков измененного узла и изменять состояние VM(а за ними потянется  и UI) в соответствии с логикой.

В тестовом json максимальное число потомков – 2, но если абстрагироваться - нужно учитывать любое число.

Лучший выход - включить здравый смысл, наложить ограничения на условия, загуглить готовые алгоритмы с деревьями и попытаться подредактировать под свои нужды.

RxJava, RxBinding
----------
Все в интернете намекает на то, что нужно почитать про RxBinding

https://academy.realm.io/posts/donn-felker-reactive-android-ui-programming-with-rxbinding/
http://reactivex.io/documentation/operators/debounce.html

должно получиться что-то похожее:

```java
EditText cardNumber = (EditText) v.findViewById(R.id.cardNum);

Subscription editCardNumberSubscription =
    RxTextView.textChanges(cardNumber)
      .debounce(500, TimeUnit.MILLISECONDS) // задержка перед обработкой строки
      .map(CharSequence::toString) // текст поля, подлежащий валидации
      .observeOn(AndroidSchedulers.mainThread()) // обработка на UI потоке
      .subscribe(text -> {
                    element.getView().setText(text);
                    if (валидаторОК) {
                        // --
                    } else {
                        // валидатор не ОК, какие-то действия
                    }
                });
```
