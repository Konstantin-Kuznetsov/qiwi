# qiwi test task
Задача
Отрисовать форму, поведение и вид которой определяется файлом в формате json (содержание файла находится в конце описания
задания и по урлу https://w.qiwi.com/mobile/form/form.json).
Форма должна реагировать на пользовательский ввод описанным в файле поведением.
Валидацию текстовых полей ввода можно проводить по кнопке "валидировать", но в идеале, использовать RxJava throttle метод, то есть
пользователь вводит, что хочет, и если ввода нет определенное количество времени – валидировать содержимое поля.
Можно использовать любой архитектурный паттерн, но для этой задачи неплохо подходит MVVM. Очень желательно разделять логику
построения дерева и рендеринг формы.


> **Использованные библиотеки:** 
----------
> - okhttp3
> - gson
> - rxjava2
> - rxbinding2
> - dagger2
> - UI - constraint-layout, RecyclerView

Решение
----------

![вид](https://user-images.githubusercontent.com/18750579/34156995-aa42a1c8-e4d0-11e7-8ca7-5be286dd611a.gif)

- Идея решения - разместить создаваемые View в ленте RecyclerView, а при необходимости перестроить интерфейс - изменяем в адаптере этого списка набор данных и оповещаем его, `notifyDataSetChanged()`

- При создании активити - скачивается json из задания с помощью OkHTTP3, на эти данные подписывается презентер, начинающий построение UI после получения файла. При первом создании UI при запуске приложения, автоматически выбирается первый элемент спиннера и остальные элементы строятся на основании этого. 

- При перестроении UI(выбор другого элемента спиннера), проходим по всем `Element` из списка отображаемых элементов и удаляем рекурсивно всех потомков(и потомков потомков, и т.д), которые становятся невидимы при новой конфигурации.

- Добавление в дерево элементов происходит в момент, когда вызывается `onBindViewHolder()` адаптера. Берется очередной `Element`, определяется его тип - спиннер или текстовое поле и генерируется UI соответствующего типа. Для каждого элемента, если это предусмотрено в полученном json, создается свой `StringValidator`.

- Т.к заданием предусмотрено отображение корректности ввода для текстовых полей и подсказок о предполагаемых данных - в разметку таких элементов включены `TextInputLayout` и вложенный `TextInputEditText`.

- Проверка корректности ввода сделана с применением библиотеки `RxBinding`. Для каждого элемента создается слушатель изменений с помощью методов этой библиотеки `RxTextView.textChanges` - для текста и `RxAdapterView.itemSelections`. 
Выбор другого элемента спиннера инициирует перестроение UI, а ввод текста инициирует проверку его валидатором.

Пример с текстовым полем:

```java
// Disposable editTextWatcher = RxTextView.textChanges(viewHolder.getTextInputLayout().getEditText())
                .debounce(500, TimeUnit.MILLISECONDS) // задержка 500мс перед обработкой
                .map(CharSequence::toString)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(currText -> {
                    // проверка на пустое поле - чтобы ошибка не светилась сразу при показе формы
                    // если текст есть и не проходит валидацию - устанавливаем ошибку
                    if (!currText.equals(EMPTY_STRING) &&!stringValidator.isValid(currText)) {
                        viewHolder.getTextInputLayout().setError(stringValidator
                                .getValidatorInstance()
                                .getMessage()); // установка ошибки текстовому полю
                    } else viewHolder.getTextInputLayout().setError(EMPTY_STRING); // сброс ошибки
                });
```
- В соответствии с требованием разнести логику по работе с деревом и конструирования отдельных элементов было принято следующее решение:
`ItemsRecyclerAdapter` - адаптер с генерируемыми элементами, обрабатывает только коллбэки RecyclerView.
`UIConstructor` - класс, содержащий `initiateEditTextView()` и `initiateSpinnerView()` для, собственно генерации элемента на основе переданного Element и initiateItems() для первоначального заполнения списка элементов, вызывается один раз после получения json от сервера.
`UITreeIterator` - содержит методы для обхода дерева зависимостей компонентов и добавления/удаления новых элементов.

- В остальном все стандартно, структурно тут MVP.
